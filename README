.Author
	Misa.Z misa@rokid.com

.License
	under GPL.

.About
	This TinyJS intepretor engine core was forked from https://github.com/gfwilliams/tiny-js.git, by Gordon Williams <gw@pur3.co.uk>.
	fixed some bugs and done lots of jobs on native interface framework design.

	Bytecode compiler and vm are all wrote by Misa.Z. The interpretor and bytecode runtime share the same native functions interface.	

.How to do arm cross compile on mac osx:
 
	download arm-toolchain for macosx from:
	https://github.com/downloads/UnhandledException/ARMx/ARMx-2009q3-67.tar.bz2

	tar -zx -C ./ --strip-components 1 -f ARMx-2009q3-67.tar.bz2 

	add the path which has 'arm-none-linux-gnueabi-g++' to default paths. 

	.to compile intel pc elf:
		make

	.to compile arm elf:
		make arm

----------------------------------------------------------------------------------------
TinyJS source code reading guide. by Misa.Z(misa.zhu@gmail.com)
----------------------------------------------------------------------------------------

Directories: 
	|
	+-	TinyJS : Interpreter.
	+-  demos : Demos for embedded TinyJS in your c++ project.
	+-	jsvm : Bytecode compiler and virtual machine.
	+-	libs : 3rd libs.
	+-	native : native class/functions extend.
	+-	test : test and demo scripts.

1.Bytecode design (Bytecode.h, Bytecode.cpp)

TinysJS bytecode has been designed by very simple way, it has only two parts: "instruction set" and "string table". Instruction is 32 bits size with 16 bits high for instruction code (short as INSTR), and 16 bit low for short int (SINT) or offset of string table (SOFF).

Instruction set:
				-------------------
				| 32 bits         |
				-------------------
				| instruction 0   |
				| instruction 1   |
				| instruction 2   |
				| instruction 3   |
				| ......          |
				| instruction n-1 |
				| instruction n   |
				-------------------

String table:
				-----------------
				|index | string |
				-----------------
				| 0    | str0   |
				| 1    | str1   |
				-----------------

Instruction:
				-------------------------
				| 16 bits   | 16 bits   |
				-------------------------
				| INSTR     | SINT/SOFF |
				-------------------------

		INSTR definition:
				INSTR_NIL					= 0x0000; // NIL									: Do nothing.

				INSTR_VAR					= 0x0001; // VAR x								: declare var x
				INSTR_CONST				= 0x0002; // CONST x							: declare const x
				INSTR_LOAD				= 0x0003; // LOAD x								: load and push x 
				INSTR_STORE				= 0x0004; // STORE x							: pop and store to x
				INSTR_GET					= 0x0005; // getfield
				INSTR_ASIGN				= 0x0006; // ASIGN								: =

				INSTR_INT					= 0x0007; // INT int 							: push int
				INSTR_FLOAT				= 0x0008; // FLOAT float					: push float 
				INSTR_STR					= 0x0009; // STR "str"						: push str
				INSTR_ARRAY_AT		= 0x000A; // ARRAT 								: get array element at

				INSTR_CALL				= 0x0010; // CALL x								: call function x and push res
				INSTR_FUNC				= 0x0011; // FUNC x								: function definetion x
				INSTR_ARG					= 0x0012; // : function arg
				INSTR_FUNC_END		= 0x0013; // FUNC_END x						: function definetion end offset x

				INSTR_NOT					= 0x0020; // NOT									: !
				INSTR_MULTI				= 0x0021; // MULTI								: *
				INSTR_DIV					= 0x0022; // DIV									: /
				INSTR_MOD					= 0x0023; // MOD									: %
				INSTR_PLUS				= 0x0024; // PLUS									: + 
				INSTR_MINUS				= 0x0025; // MINUS								: - 
				INSTR_NEG					= 0x0026; // NEG									: negate -
				INSTR_PPLUS				= 0x0027; // PPLUS								: ++
				INSTR_MMINUS			= 0x0028; // MMINUS								: --
				INSTR_LSHIFT			= 0x0029; // LSHIFT								: <<
				INSTR_RSHIFT			= 0x002A; // RSHIFT								: >>
				INSTR_URSHIFT			= 0x002B; // URSHIFT							: >>>

				INSTR_EQ					= 0x0030; // EQ										: ==
				INSTR_NEQ					= 0x0031; // NEQ									: !=
				INSTR_LEQ					= 0x0032; // LEQ									: <=
				INSTR_GEQ					= 0x0033; // GEQ									: >=
				INSTR_GRT					= 0x0034; // GRT									: >
				INSTR_LES					= 0x0035; // LES									: <

				INSTR_AAND				= 0x0040; // AAND									: &&
				INSTR_OOR					= 0x0041; // OOR									: ||
				INSTR_OR					= 0x0042; // OR										: |
				INSTR_XOR					= 0x0043; // XOR									: ^
				INSTR_AND					= 0x0044; // AND									: &


				INSTR_BREAK				= 0x0050; // : break
				INSTR_CONTINUE		= 0x0051; // : continue
				INSTR_RETURN			= 0x0052; // : return none value
				INSTR_RETURNV			= 0x0053; // : return with value

				INSTR_NJMP				= 0x0054; // NJMP x								: Condition not JMP offset x 
				INSTR_JMPB				= 0x0055; // JMP back x						: JMP back offset x  
				INSTR_NJMPB				= 0x0056; // NJMP back x					: Condition not JMP back offset x 
				INSTR_JMP					= 0x0057; // JMP x								: JMP offset x  

				INSTR_TRUE				= 0x0060; // : true
				INSTR_FALSE				= 0x0061; // : false
				INSTR_NULL				= 0x0062; // : null
				INSTR_UNDEF				= 0x0063; // : undefined

				INSTR_NEW					= 0x0070; // : new

				INSTR_POP					= 0x0080; // : pop and release

				INSTR_OBJ					= 0x0090; // : object for JSON 
				INSTR_OBJ_END			= 0x0091; // : object end for JSON 
				INSTR_MEMBER			= 0x0092; // : object member for JSON 



